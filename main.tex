\documentclass[12pt, a4paper]{article}
\usepackage[italian]{babel}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{subcaption}
\usepackage{lipsum} 
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,     % Abilita i collegamenti colorati
    linkcolor=black,      % Colore dei collegamenti interni
    citecolor=green,     % Colore dei collegamenti alle citazioni
    urlcolor=magenta     % Colore dei collegamenti URL
}

\title{Bookkepper test}
\author{Luca Falasca}

\begin{document}

\maketitle
\tableofcontents

\listoffigures
\listoftables

\newpage

\section{Introduction}

\section{Bookkeeper}
\subsection{Journal}
\subsubsection{Descrizione}
Path: org.apache.bookkeeper.bookie.Journal.java

\paragraph{listJournalIds}
Lists all journal IDs filtered by a specified journal ID filter.

This method scans the given directory containing journal log files and extracts
journal IDs based on the provided filter. If no filter is provided, all journal
IDs present in the directory are returned.


\paragraph{Input:}
\begin{itemize}
  \item journalDir journal dir : The directory containing journal log files.
  \item filter journal id filter
\end{itemize}
\paragraph{Output:}
    list of filtered ids

\subsubsection{Category Partition}
\paragraph{journalDir}
\begin{itemize}
  \item \{Directory contenente file di log\}
  \item \{Directory contenente file di log e altri file\}
  \item \{Directory contenente file non di log\}
  \item \{path non esistente\}
  \item \{Path di un file\}
  \item null
\end{itemize}
Siccome la variabile journalDir è il path di una directory, ho partizionato 
il dominio in base al contenuto della directory e al suo effettivo utilizzo, rendendo la scelta delle partizioni 
una conseguenza del fatto che il metodo lavora su file di log.

\paragraph{JournalIdFilter}
\begin{itemize}
    \item Filtro esistente
    \item Filtro sempre True
    \item Filtro sempre False
    \item Filtro inesistente
    \item null
\end{itemize}

\subsubsection{Boundary Analysis}
Andiamo a definire per ogni partizione i Boundary values

\paragraph{journalDir}
\begin{itemize}
  \item \{Directory contenente 1 file di log\}
  \item \{Directory contenente 1 file di log e 1 file di testo\}
  \item \{Directory contenente 1 file di testo\}
  \item \{path non esistente\}
  \item \{Path di un file di log\}
  \item null
\end{itemize}

\paragraph{JournalIdFilter}
\begin{itemize}
    \item JournalRollingFilter  -- Questo filtro è l'unico filtro esistente utilizzato nell'applicazione, 
    tuttavia siccome viene utilizzato in un contesto molto specifico dell'applicazione e non è un filtro generico, l'ho rimpiazzato
    con una sua versione semplificata più generale. Altrimenti non sarebbe stato adatto ad un test di unità, ma sarebbe stato 
    più un test di integrazione
    \item Filtro sempre True
    \item Filtro sempre False
    \item MyFilter -- Questo filtro è un filtro personalizzato creato appositamente per questo test che va a filtrare i journal
    in base al loro nome, in particolare se il journalId è > 0 viene accettato, altrimenti no. 
    Questo filtro ha lo scopo di testare come si comporta il sistema in caso di definizione di un nuovo filtro non già esistente 
    nel sistema e quindi non è importante il tipo di filtraggio che fa.
    \item null
\end{itemize}

\paragraph{}

Siccome i due parametri di input sono abbastanza scorrelati tra loro ha più senso adottare un approccio 
unidimensionale piuttosto che uno multidimensionale che sarebbe più adatto quando ci sono delle interazioni forti
e che portano alla necessità di testare tutte le combinazioni tra i parametri. Inoltre avendo un approccio multidimensionale
si finirebbe probabilemente per avere molti test non rilevanti e vanno a coprire scenari già coperti, e quindi sarebbero inutili.
\\ Enumeriano ora i casi di test derivanti da quest prima analisi (Tabella \ref{tab:categoryPartition1ListJournalIds})

Codice sorgente di JournalTest (Figura \ref{fig:code1})

\subsubsection{Adequacy Control Flow}
Ora per verificare l'adeguatezza dei casi di test, vado a definire dei critedi di adeguatezza. \\ \\
\textbf{Criteri di adeguatezza black box}
\paragraph{} 
documentazione a disposizione:  \\
javadoc:
\begin{verbatim}
/**
* List all journal ids by a specified journal id filer.
*
* @param journalDir journal dir
* @param filter journal id filter
* @return list of filtered ids
*/
\end{verbatim}

 documentazione apache:
 Journals
A journal file contains BookKeeper transaction logs. 
Before any update to a ledger takes place, the bookie ensures that a transaction describing 
the update is written to non-volatile storage. A new journal file is created once the bookie 
starts or the older journal file reaches the journal file size threshold. \\

Possiamo dedurre da queste documentazioni che questo metodo ricava gli id dei journal in una 
determinata cartella, filtrandoli in base ad un filtro specificato, se non viene specificato 
nessun filtro, allora vengono restituiti tutti gli id dei journal presenti nella cartella.

La Figura \ref{fig:listJournalIdsCFG} mostra un diagrammma 
funzionale del metodo listJournalIds.
A partire da questo definisco i seguenti criteri di adeguatezza:
\begin{itemize}
  \item almeno un test con un filtro
  \item almeno un test senza filtro
  \item almeno un test senza journal nella cartella
  \item almeno un test con almeno un journal nella cartella
\end{itemize}
In questo caso i criteri di adeguatezza sono già stati soddisfatti 
dai casi di test precedentemente descritti. \\



Dal diagramma precedente possiamo 
ricavare un control flow graph (Figura \ref{fig:listJournalIdsCFG}), per poi
utilizzare dei criteri di copertura basati sul control flow

Dato che ho un approccio black box e quindi non sto utilizzando il codice sorgente per verificare l'adeguatezza dei casi di test,
ipotizzo in base agli input se un caso di test andrà a coprire un certo arco del CFG o meno.
Dato che in questa fase sto avendo un approccio black box, e quindi basato sulla funzionalità del metodo, 
eviterò di utilizzare la coverage come parametro di adeguatezza, in quanto non è possibile ricavare
dall'output del metodo se un certo arco è stato coperto o meno, ma solo se il risultato è corretto oppure no.
Quindi valuterò la copertura del CFG solo in una fase successiva, quando prenderò in considerazione
anche il codice sorgente (approccio whitebox), utilizzando la coverage come parametro di adeguatezza.
Quello che farò in questa fase è quindi valutare se i casi di test che ho definito in precedenza
coprono tutti gli archi del CFG, in base alla mia conoscenza del metodo e dei suoi input, e nel caso
aggiungere quelli mancanti.

Arco (1,2)  $\rightarrow$ textgreater Tutti i test che hanno almeno un file di log coprono questo caso, quindi non è necessario aggiungere ulteriori test
Arco (2,3)  - \> Tutti i test che hanno almeno un file di log e un filtro non null coprono questo caso, quindi non è necessario aggiungere ulteriori test
Arco (2,4)  -\> 
Questo arco non è coperto perchè manca un test che abbia almeno un file di log e il filtro null. Basta quindi aggiungere il 
test necessario (Figura \ref{tab:ACF1ListJournalIds})


Arco (3,4)  -\> Tutti i test che hanno almeno un file di log e un filtro non null coprono questo caso, quindi non è necessario aggiungere ulteriori test


è stato necessario quindi aggiungere un caso di test e quindi la attuale test suite è descritta nella Tabella \Ref{tab:ACF2ListJournalIds}


Ora andiamo a valutare la coverage ottenuta con jacoco con i casi di test definiti
fino ad ora (Figura \ref{fig:JacocoCoveragelistJournalIds1.png})

Come si può vedere dalla figura \ref{fig:JacocoCoveragelistJournalIds1.png},
la statement coverage è del 100\% (colonna missed instruction), 
e quindi tutte le linee di codice del metodo sono state eseguite. \\
Invece la condition coverage (colonna missed branches) e del 83\%, ed è quindi migliorabile.
Andando a vedere in dettaglio il report, si può notare che una condizione che non è stata coperta
è una delle 4 combinazioni dell'if a riga 106 come si vede dalla figura \ref{fig:MissedBranchListJournalIds.png}
\\
La condizione presa in esame è la seguente:
\begin{verbatim}
logFiles == null || logFiles.length == 0
\end{verbatim}

il branch mancato è quello dove logFiles == null, questo perchè se il parametro di input journalDir
 è null non esegue proprio il metodo listFiles().
questo è dovuto al fatto che il path non era esistente e quindi il metodo tornava null.
Andiamo quindi a definire un caso di test che copra questo branch
Per farlo andiamo semplicemente basta aggiungere un category partition che copre il caso di una cartella esistente ma vuota
(Tabella \ref{tab:ACF3ListJournalIds})

Ora quindi l'insieme dei test è quello mostrato nella tabella \ref{tab:ACF4ListJournalIds}, 
e grazie a questo test la condition coverage è salita al 91\% (Figura \ref{fig:JacocoCoveragelistJournalIds2.png}),
con un aumento del 8%.

 \subsubsection{Adequacy Data Flow}

 Andiamo ora ad fare un lavoro di adeguatezza del dataflow utilizzando il framework badua per calcolare la all-uses coverage. \\
Dalla Figura \ref{fig:listJournalIds_badua} possiamo calcolare la all uses coverage. \\
\(CU_c + PU_c = 18\) \\
\( (CU + PU) - (CU\textsubscript{f} + PU\textsubscript{f}) = 18 + 2 = 20\) \\ \\
\[\frac{{CU\textsubscript{c} + PU\textsubscript{c}}}{{(CU + PU) - (CU\textsubscript{f} + PU\textsubscript{f})}} = \frac{{18}}{{20}} = 0.9\]

Ci sono quindi 2 coppie def-use che non sono state coperte, e quindi la all uses coverage è del 90\%.
Per aumentare la coverage è necessario aggiungere un caso di test che copra almeno una di queste coppie.
Prendiamo in considerazione la coppia def-use sulla variabile filter non coperta. Si tratta di una coppia c-use 
dove il target è il continuo del ciclo for in cui è contenuto lo statement. In effetti non c'è nessun caso di test
che va a coprire il caso in cui la coppia def-use è coperta e successivamente continua il ciclo.
Per fare ciò vado ad aggiungere un caso di test che continua il ciclo for una volta rifiutata 
l'espressione booleana in cui è contentuto il comando. Per fare ciò basta aggiungere una cartella in cui controlla
un altro id di journal dopo averne rifiutato uno. Effettivamente badua è servito a migliorare la qualità dei 
test perchè nonostante la coverage
coprisse già queste righe di codice non era stata in grado di intercettare la mancanza
di test su questo comportamento. \\W
Il caso di test è descritto nella Tabella \ref{tab:ADF1ListJournalIds}. Quello che ho fatto è creare una nuova
cartella che contiene due file di log e un filtro con condizione >1, il primo dei due file viene rifiutato 
e il secondo invece viene accettato. In questo modo il metodo dopo aver scartato il primo file di log, continua
con la sua ricerca e trova il secondo file di log che viene accettato. In questo modo la coppia
def-use sulla variabile filter viene coperta e la all uses coverage sale (Figura \Ref{fig:listJournalIds_badua2})

Con questo caso di test vado a coprire anche l'altra coppia def-use che non era stata coperta.
Questo succede perchè anche a lei mancava il caso in cui una volta che il filtro rifiutava un id il
metodo continuava la sua ricerca e trovava un id successivo.

Così la all-use coverage riesce a raggiungere il 100\% \\ 

Inoltre come effetto secondario si può notare che anche
la condition coverage è salita al 100\% (Figura \ref{fig:listJournalIds_jacoco4})

\subsubsection{Mutation Testing}
Andiamo ora a fare un lavoro di adeguatezza utilizzando il framework pitest per calcolare la mutation coverage. \\
Come si può notare dalla Figura \ref{fig:listJournalIds_pitest} la mutation coverage è dello 0\%, ad una prima occhiata
sembrerebbe perchè tutte le mutazioni create da pit non sono state rilevate. Tuttavia se andiamo a verificare 
ogni mutazione manualmente in realtà i test falliscono e quindi in realtà sembrerebbe che ci sia un bug su pit. \\
Indagando meglio ho scoperto che questo comportamento è probabilemente dovuto ad fatto che il metodo listJournalIds
è un metodo statico e per il modo in cui pit inserisce le mutazione può creare problemi. Purtroppo non sono riuscito a 
risolvere questo problema, quindi calcolerò la coverage a mano andando a verificare mutazione per mutazione. \\

Ad esempio prendiamo la mutazione a riga 112, se andiamo nel codice di Bookkeeper e lo modifichiamo per inserire
la mutazione (Figura \Ref{fig:PitMutation1}) e poi eseguiamo i test, possiamo notare che più di un test fallisce, quindi
in realtà la mutazione è stata rilevata dalla test suite. (Figura \ref{fig:PitMutation2})

Questo succede per tutte le mutazioni, tranne per quella a riga 125, che non viene rilevata dalla test suite.

Quindi possiamo calcolare la mutation coverage come segue:
\[\frac{{Mutazioni rilevate}}{{Mutazioni totali}} = \frac{{6}}{{7}} = 0.85\]

Per aumentare la coverage vado quindi a modificare la test suite per coprire anche la mutazione a riga 125.
il

\subsection{Classe 2}
\subsubsection{Descrizione}
\subsubsection{Category Partition}
\subsubsection{Boundary Analysis}
\subsubsection{Adequacy Control Flow}
\subsubsection{Adequacy Data Flow}
\subsubsection{Mutation Testing}

\section{Avro}
\subsection{Classe 1}
\subsubsection{Descrizione}
\subsubsection{Category Partition}
\subsubsection{Boundary Analysis}
\subsubsection{Adequacy Control Flow}
\subsubsection{Adequacy Data Flow}
\subsubsection{Mutation Testing}

\subsection{Classe 2}
\subsubsection{Descrizione}
\subsubsection{Category Partition}
\subsubsection{Boundary Analysis}
\subsubsection{Adequacy Control Flow}
\subsubsection{Adequacy Data Flow}
\subsubsection{Mutation Testing}














\begin{table}[ht]
  \centering
  \caption[Journal: Test Suite - Category Partition]{Test Suite derivante dalla category partition e dalla boundary analysis}
  \begin{tabular}{|c|c|c|}
  \hline
  journalDir & JournalIdFilter & Risultato Atteso \\
  \hline
  {Directory contenente 1 file di log} & JournalRollingFilter & [1] \\
  {Directory contenente 1 file di log e 1 file di testo} & Filtro sempre True & [1] \\
  {Directory contenente 1 file di testo} & Filtro sempre False & [ ] \\
  {path non esistente} & MyFilter & [ ] \\
  {Path di un file di log} & null & Exception \\
  null & null & Exception \\
  \hline
  \end{tabular}
  \label{tab:categoryPartition1ListJournalIds}
\end{table}

\begin{table}[ht]
  \centering
  \caption[Journal: Test Suite - Adequacy Control Flow 1]{Test per coprire l'arco (2,4)}
  \begin{tabular}{|c|c|c|}
    \hline
journalDir & JournalIdFilter & Risultato Atteso \\
  \hline
    {Directory contenente 1 file di log} & null & Exception \\
    \hline
  \end{tabular}
  \label{tab:ACF1ListJournalIds}
\end{table}

\begin{table}[ht]
  \centering
  \caption[Journal: Test Suite - Adequacy Control Flow 2]{Casi di test aggiornati per coprire l'arco (2,4)}
  \begin{tabular}{|c|c|c|}
  \hline
  journalDir & JournalIdFilter & Risultato Atteso \\
  \hline
  {Directory contenente 1 file di log} & JournalRollingFilter & [1] \\
  {Directory contenente 1 file di log e 1 file di testo} & Filtro sempre True & [1] \\
  {Directory contenente 1 file di testo} & Filtro sempre False & [ ] \\
  {path non esistente} & MyFilter & [ ] \\
  {Path di un file di log} & null & Exception \\
  null & null & Exception \\
  {Directory contenente 1 file di log} & null & Exception \\
  \hline
  \end{tabular}
  \label{tab:ACF2ListJournalIds}
\end{table}

\begin{table}[ht]
  \centering
  \caption[Journal: Test Suite - Adequacy Control Flow 3]{Test per aumentare la condition coverage}
  \begin{tabular}{|c|c|c|}
    \hline
    journalDir & JournalIdFilter & Risultato Atteso \\
    \hline
    {Directory vuota} & null & [ ] \\
    \hline
  \end{tabular}
  \label{tab:ACF3ListJournalIds}
\end{table}

\begin{table}[ht]
  \centering
  \caption[Journal: Test Suite - Adequacy Control Flow 4]{Casi di test aggiornati per aumentare la condition coverage}
  \begin{tabular}{|c|c|c|}
  \hline
  journalDir & JournalIdFilter & Risultato Atteso \\
  \hline
  {Directory contenente 1 file di log} & JournalRollingFilter & [1] \\
  {Directory contenente 1 file di log e 1 file di testo} & Filtro sempre True & [1] \\
  {Directory contenente 1 file di testo} & Filtro sempre False & [ ] \\
  {path non esistente} & MyFilter & [ ] \\
  {Path di un file di log} & null & Exception \\
  null & null & Exception \\
  {Directory contenente 1 file di log} & null & Exception \\
  {Directory vuota} & null & [ ] \\
  \hline
  \end{tabular}
  \label{tab:ACF4ListJournalIds}
\end{table}

  \begin{table}[ht]
    \centering
    \caption[Journal: Test Suite - Adequacy Data Flow 1]{Test per aumentare la all-use coverage}
    \begin{tabular}{|c|c|c|}
      \hline
      journalDir & JournalIdFilter & Risultato Atteso \\
      \hline
      {Directory con 1 file con id 1 e un file con id 2} & {Filtro con condizione >1} & [ ] \\
      \hline
    \end{tabular}
    \label{tab:ADF1ListJournalIds}
  \end{table}










  \begin{figure}
    \centering
    \begin{subfigure}[a]{0.4\linewidth}
      \includegraphics[width=\linewidth]{./images/listJournalIds.jpg}
      \caption{Functional diagram}
    \end{subfigure}
    \begin{subfigure}[b]{0.4\linewidth}
      \includegraphics[width=\linewidth]{./images/CFGlistJournalIds.jpg}
    \caption{Control Flow Graph}
    \end{subfigure}
    \caption{Diagrammi di listJournalIds}
    \label{fig:listJournalIdsCFG}
  \end{figure}

  \begin{figure}
    \includegraphics[width=\linewidth]{./images/JacocoCoveragelistJournalIds1.png}
    \caption{Jacoco coverage dilistJournalIds}
    \label{fig:listJournalIds_jacoco}
  \end{figure}

  \begin{figure}
    \includegraphics[width=\linewidth]{./images/MissedBranchListJournalIds.png}
    \caption{Jacoco coverage dilistJournalIds}
    \label{fig:listJournalIds_jacoco2}
  \end{figure}

  \begin{figure}
    \includegraphics[width=\linewidth]{./images/JacocoCoveragelistJournalIds2.png}
    \caption{Jacoco coverage dilistJournalIds}
    \label{fig:listJournalIds_jacoco3}
  \end{figure}

  \begin{figure}
    \includegraphics[width=\linewidth]{./images/code1.png}
    \caption{Codice sorgente di JournalTest}
    \label{fig:code1}
  \end{figure}

  \begin{figure}
    \includegraphics[width=\linewidth]{./images/BaduaCoveragelistJournalIds1.png}
    \caption{Badua coverage dilistJournalIds}
    \label{fig:listJournalIds_badua}
  \end{figure}

  \begin{figure}
    \includegraphics[width=\linewidth]{./images/BaduaCoveragelistJournalIds2.png}
    \caption{Badua coverage dilistJournalIds}
    \label{fig:listJournalIds_badua2}
  \end{figure}

  \begin{figure}
    \includegraphics[width=\linewidth]{./images/JacocoCoveragelistJournalIds3.png}
    \caption{Jacoco coverage dilistJournalIds}
    \label{fig:listJournalIds_jacoco4}
  \end{figure}

  \begin{figure}
    \includegraphics[width=\linewidth]{./images/PitCoverageListJournalIds1.png}
    \caption{Pitest coverage dilistJournalIds}
    \label{fig:listJournalIds_pitest}
  \end{figure}

  \begin{figure}
    \includegraphics[width=\linewidth]{./images/PitMutation1.png}
    \caption{Mutazione inserita nel codice sorgente di Bookkeeper}
    \label{fig:PitMutation1}
  \end{figure}

  \begin{figure}
    \includegraphics[width=\linewidth]{./images/PitTestFails.png}
    \caption{Mutazione inserita nel codice sorgente di Bookkeeper}
    \label{fig:PitMutation2}
  \end{figure}

\end{document}
